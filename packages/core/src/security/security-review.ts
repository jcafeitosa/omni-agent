import { execFileSync } from "node:child_process";
import { Provider } from "../index.js";
import { FindingsFilter, FindingsFilterOptions, SecurityFinding } from "./findings-filter.js";
import { parseJsonWithFallbacks } from "../helpers/json-fallback-parser.js";

export interface SecurityReviewOptions {
    provider: Provider;
    workingDirectory?: string;
    baseRef?: string;
    includeUncommitted?: boolean;
    excludedDirectories?: string[];
    filterOptions?: Omit<FindingsFilterOptions, "excludedDirectories">;
    customInstructions?: string;
}

export interface SecurityReviewResult {
    findings: SecurityFinding[];
    excludedFindings: any[];
    filteringSummary: any;
    analysisSummary: any;
    highSeverityCount: number;
    promptLength: number;
}

function listChangedFiles(workingDirectory: string, baseRef?: string): string[] {
    const args = baseRef
        ? ["diff", "--name-only", `${baseRef}...HEAD`]
        : ["diff", "--name-only", "HEAD~1...HEAD"];
    const out = execFileSync("git", args, {
        cwd: workingDirectory,
        encoding: "utf8",
        stdio: ["ignore", "pipe", "pipe"]
    });
    return out
        .split("\n")
        .map((s) => s.trim())
        .filter(Boolean);
}

function loadDiff(workingDirectory: string, baseRef?: string, includeUncommitted = true): string {
    const args = baseRef
        ? ["diff", "--unified=1", `${baseRef}...HEAD`]
        : ["diff", "--unified=1", "HEAD~1...HEAD"];
    const committed = execFileSync("git", args, {
        cwd: workingDirectory,
        encoding: "utf8",
        stdio: ["ignore", "pipe", "pipe"],
        maxBuffer: 10 * 1024 * 1024
    });

    if (!includeUncommitted) {
        return committed;
    }
    const staged = execFileSync("git", ["diff", "--unified=1"], {
        cwd: workingDirectory,
        encoding: "utf8",
        stdio: ["ignore", "pipe", "pipe"],
        maxBuffer: 10 * 1024 * 1024
    });

    return `${committed}\n${staged}`.trim();
}

function isGeneratedSection(section: string): boolean {
    const lower = section.toLowerCase();
    return (
        lower.includes("@generated") ||
        lower.includes("code generated by") ||
        lower.includes("generated file")
    );
}

function filterDiff(diff: string, excludedDirectories: string[] = []): string {
    const sections = diff.split(/(?=^diff --git )/m).filter(Boolean);
    const kept: string[] = [];

    for (const section of sections) {
        if (isGeneratedSection(section)) continue;
        const match = section.match(/^diff --git a\/(.+?) b\//m);
        const file = match?.[1] || "";
        if (excludedDirectories.length > 0 && file) {
            const isExcluded = excludedDirectories.some((dir) => {
                const normalized = dir.replace(/^\.\//, "").replace(/\/+$/, "");
                if (!normalized) return false;
                return file === normalized || file.startsWith(`${normalized}/`) || file.includes(`/${normalized}/`);
            });
            if (isExcluded) continue;
        }
        kept.push(section);
    }
    return kept.join("");
}

function buildPrompt(changedFiles: string[], diff: string, customInstructions?: string): string {
    return `You are a senior security engineer. Analyze only newly introduced vulnerabilities in this code diff.
Return JSON only in this shape:
{"findings":[{"file":"path","line":1,"severity":"HIGH|MEDIUM|LOW","category":"id","description":"...", "exploit_scenario":"...", "recommendation":"...", "confidence":0.9}],"analysis_summary":{"files_reviewed":0,"high_severity":0,"medium_severity":0,"low_severity":0,"review_completed":true}}

Hard exclusions:
- Do not report rate-limiting recommendations.
- Do not report generic DOS/resource exhaustion concerns.
- Do not report open-redirect-only concerns.

Changed files:
${changedFiles.map((f) => `- ${f}`).join("\n")}

${customInstructions ? `Additional instructions:\n${customInstructions}\n` : ""}

Diff:
\`\`\`
${diff}
\`\`\`
`;
}

export async function runSecurityReview(options: SecurityReviewOptions): Promise<SecurityReviewResult> {
    const workingDirectory = options.workingDirectory || process.cwd();
    const changedFiles = listChangedFiles(workingDirectory, options.baseRef);
    const rawDiff = loadDiff(workingDirectory, options.baseRef, options.includeUncommitted !== false);
    const filteredDiff = filterDiff(rawDiff, options.excludedDirectories);
    const prompt = buildPrompt(changedFiles, filteredDiff, options.customInstructions);

    const response = await options.provider.generateText([{ role: "user", content: prompt } as any], []);
    const parsed = parseJsonWithFallbacks<any>(response.text || "");
    const findings = parsed.success && Array.isArray(parsed.data?.findings) ? parsed.data.findings : [];
    const analysisSummary = parsed.success && parsed.data?.analysis_summary ? parsed.data.analysis_summary : {};

    const filter = new FindingsFilter({
        excludedDirectories: options.excludedDirectories,
        ...(options.filterOptions || {})
    });
    const filtered = await filter.filterFindings(findings);

    const highSeverityCount = filtered.filteredFindings.filter((f) => String(f.severity || "").toUpperCase() === "HIGH").length;

    return {
        findings: filtered.filteredFindings,
        excludedFindings: filtered.excludedFindings,
        filteringSummary: filtered.analysisSummary,
        analysisSummary,
        highSeverityCount,
        promptLength: prompt.length
    };
}
